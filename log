diff --git a/glyxtoolms/gui/AnnotatedPlot.py b/glyxtoolms/gui/AnnotatedPlot.py
index c9657ca..921bfad 100644
--- a/glyxtoolms/gui/AnnotatedPlot.py
+++ b/glyxtoolms/gui/AnnotatedPlot.py
@@ -1,6 +1,13 @@
 from glyxtoolms.gui import FramePlot
 import glyxtoolms
 
+class Annotatable(object):
+    
+    def __init__(self,x=0,y=0):
+        """  Annotatable object, has to provide a x and y coordinate """
+        self.x = x
+        self.y = y
+
 class AnnotatedPlot(FramePlot.FramePlot):
 
     def __init__(self, master, model, height=300, width=800, xTitle="", yTitle=""):
@@ -10,7 +17,8 @@ class AnnotatedPlot(FramePlot.FramePlot):
 
         self.master = master
         self.peaksByItem = {}
-        self.annotations = []
+        self.annotations = {}
+        self.series = {}
         self.annotationItems = {}
         self.currentAnnotation = None
 
@@ -18,7 +26,8 @@ class AnnotatedPlot(FramePlot.FramePlot):
         
         self.canvas.bind("<Button-1>", self.button1Pressed, "+")
         self.canvas.bind("<ButtonRelease-1>", self.button1Released, "+")
-        self.canvas.bind("<B1-Motion>", self.button3Motion, "+")
+        #self.canvas.bind("<B1-Motion>", self.button3Motion, "+")
+        self.canvas.bind("<Motion>", self.mouseMoveEvent, "+")
 
         self.canvas.bind("<Button-3>", self.button3Pressed, "+")
         self.canvas.bind("<ButtonRelease-3>", self.button3Released, "+")
@@ -26,23 +35,137 @@ class AnnotatedPlot(FramePlot.FramePlot):
         
         self.canvas.bind("<Delete>", self.deleteAnnotation, "+")
         
+        
+        
         # add ruler toggle
-        self.rulerbutton = self.toolbar.addButton("ruler","defaultgroup")
+        self.rulerbutton = self.toolbar.addButton("ruler","toggle")
+        
+    def _paintCanvas(self, addToHistory=True):
+        """ Method override to inject annotation painting """
+        super(AnnotatedPlot, self)._paintCanvas(addToHistory)
+        self.paintAllAnnotations()
 
-    def findPeakAt(self, pixelX):
-        overlap = set(self.canvas.find_overlapping(pixelX-10,
-                                                   0,
-                                                   pixelX+10,
-                                                   self.height))
+    def clearAnnotatableList(self):
+        self.peaksByItem = {}
+
+    def addAnnotatableItem(self, item, annotatableObject):
+        self.peaksByItem[item] = annotatableObject
+        
+    def addSeries(self, series, color):
+        self.series[series] = {"locked":True, "hidden":False, "color":color}
+        self.annotations[series] = []
+
+    def addAnnotation(self, annotation, series):
+        annotation.series = series
+        if not series in self.annotations:
+            return
+        if len(self.annotations[series]) == 0:
+            annotation.nr = 0
+        else:
+            maxnr = max([a.nr for a in self.annotations[series]])
+            annotation.nr = maxnr+1
+        #self.annotations[series] = self.annotations.get(series,[]) + [annotation]
+        self.annotations[series].append(annotation)
+
+    def findItemAt(self, pixelX=None, pixelY=None):
+        if pixelX == None and pixelY == None:
+            return
+        if pixelX == None:
+            xmin = 0
+            xmax = self.height
+        else:
+            xmin = pixelX - 10
+            xmax = pixelX + 10
+        if pixelY == None:
+            ymin = 0
+            ymax = self.height
+        else:
+            ymin = pixelY - 10
+            ymax = pixelY + 10
+        overlap = set(self.canvas.find_overlapping(xmin, ymin,
+                                                   xmax, ymax))
         peaks = []
+        annotations = []
         for item in overlap:
+            minlist = []
+            if pixelX != None:
+                minlist.append(abs(self.canvas.coords(item)[0] - pixelX))
+            if pixelY != None:
+                minlist.append(abs(self.canvas.coords(item)[1] - pixelY))
+            mini = min(minlist)
+                
             if item in self.peaksByItem:
-                peaks.append((abs(self.canvas.coords(item)[0] - pixelX), self.peaksByItem[item]))
+                peaks.append((mini, item))
+            if item in self.annotationItems:
+                annotations.append((mini, item))
         if len(peaks) == 0:
             peak = None
         else:
             peak = min(peaks)[1]
-        return peak
+        if len(annotations) == 0:
+            annotation = None
+        else:
+            annotation = min(annotations)[1]
+        return {"annotatable":peak, "annotation":annotation}
+
+    def findObjectAt(self, pixelX=None, pixelY=None):
+        items = self.findItemAt(pixelX, pixelY)
+        annotatableItem = items["annotatable"]
+        annotationItem = items["annotation"]
+        if annotatableItem == None:
+            peak = None
+        else:
+            peak = self.peaksByItem[annotatableItem]
+        if annotationItem == None:
+            annotation = None
+        else:
+            annotation = self.annotationItems[annotationItem]
+        return {"annotatable":peak, "annotation":annotation}
+
+#    def findPeakAt(self, pixelX):
+#        overlap = set(self.canvas.find_overlapping(pixelX-10,
+#                                                   0,
+#                                                   pixelX+10,
+#                                                   self.height))
+#        peaks = []
+#        for item in overlap:
+#            if item in self.peaksByItem:
+#                peaks.append((abs(self.canvas.coords(item)[0] - pixelX), self.peaksByItem[item]))
+#        if len(peaks) == 0:
+#            peak = None
+#        else:
+#            peak = min(peaks)[1]
+#        return peak
+    
+#    def findAnnotationAt(self.pixelX, pixelY):
+#        overlap = set(self.canvas.find_overlapping(pixelX-10,
+#                                           0,
+#                                           pixelX+10,
+#                                           self.height))
+#        for item in overlap:
+#            if item in self.annotationItems:
+                
+    def mouseMoveEvent(self, event):
+        if self.rulerbutton.active == False:
+            return
+        nearest = self.findItemAt(pixelX=event.x, pixelY=event.y)
+        annotationItem = nearest["annotation"]
+        annotatableItem = nearest["annotatable"]
+        if annotationItem != None:
+            annotation = self.annotationItems[annotationItem]
+            if annotation.items[annotationItem] == "line":
+                self.canvas.config(cursor="pencil")
+            else:
+                self.canvas.config(cursor="plus")
+            #if self.canvas.coords(annotationItem)[0] - event.x < 0:
+            #    self.canvas.config(cursor="left_side")
+            #else:
+            #    self.canvas.config(cursor="right_side")
+        elif annotatableItem != None:
+            self.canvas.config(cursor="bottom_side")
+        else:
+            self.canvas.config(cursor="")
+        
 
     def button1Pressed(self, event):
         # search nearest annotation
@@ -70,7 +193,7 @@ class AnnotatedPlot(FramePlot.FramePlot):
             return
         if not self.currentAnnotation.selected == "text":
             self.currentAnnotation.y = event.y
-        peak = self.findPeakAt(event.x)
+        peak = self.findObjectAt(pixelX=event.x)["annotatable"]
 
         if peak is not None:
             if self.currentAnnotation.selected == "x1":
@@ -83,7 +206,7 @@ class AnnotatedPlot(FramePlot.FramePlot):
     def button3Pressed(self, event):
         if self.rulerbutton.active == False:
             return
-        peak = self.findPeakAt(event.x)
+        peak = self.findObjectAt(pixelX=event.x)["annotatable"]
         y = self.convYtoB(event.y)
         
         if peak is not None:
@@ -102,10 +225,11 @@ class AnnotatedPlot(FramePlot.FramePlot):
             return
         if self.currentAnnotation is None:
             return
-        peak = self.findPeakAt(event.x)
-            
+        peak = self.findObjectAt(pixelX=event.x)["annotatable"]
+
         if peak is  None:
             return
+        
         x = peak.x
 
         if self.currentAnnotation.selected == "x1":
@@ -123,21 +247,28 @@ class AnnotatedPlot(FramePlot.FramePlot):
         if self.currentAnnotation is None:
             return
         self.currentAnnotation.y = event.y
-        peak = self.findPeakAt(event.x)
+        peak = self.findObjectAt(pixelX=event.x)["annotatable"]
         if peak is not None:
             if self.currentAnnotation.selected == "x1":
                 self.currentAnnotation.x1 = peak.x
             elif self.currentAnnotation.selected == "x2":
                 self.currentAnnotation.x2 = peak.x
             self.currentAnnotation.text = str(round(abs(self.currentAnnotation.x1-self.currentAnnotation.x2),4))
-            self.annotations.append(self.currentAnnotation)
+            self.addAnnotation(self.currentAnnotation, "test")
+            #series = self.currentAnnotation.series
+            #self.annotations[series] = self.annotations.get(series,[]) + [self.currentAnnotation]
         self.currentAnnotation = None
         self.paintAllAnnotations()
 
     def deleteAnnotation(self, event):
         if self.currentAnnotation is None:
             return
-        self.annotations.remove(self.currentAnnotation)
+        series = self.currentAnnotation.series
+        if not series in self.annotations:
+            return
+        if not self.currentAnnotation in self.annotations[series]:
+            return
+        self.annotations[series].remove(self.currentAnnotation)
         self.currentAnnotation = None
         self.paintAllAnnotations()
         
@@ -152,43 +283,98 @@ class AnnotatedPlot(FramePlot.FramePlot):
     def paintAllAnnotations(self):
         self.canvas.delete("annotation")
         self.annotationItems = {}
-        for annotation in self.annotations:
-            self.paintAnnotation(annotation)
+        dimensions = {}
+        # caculate dimensions of each series
+        for series in self.annotations:
+            dimensions[series] = {}
+            
+            #for annotation in sorted(self.annotations[series], key=lambda a: abs(a.x2-a.x1), reverse=True):
+            for annotation in sorted(self.annotations[series], key=lambda a: (a.x1,-abs(a.x2-a.x1))):
+                #x1 = int(self.convAtoX(annotation.x1))
+                #x2 = int(self.convAtoX(annotation.x2))
+                x1 = annotation.x1
+                x2 = annotation.x2
+                level = 0
+                while True:
+                    if level not in dimensions[series]:
+                         dimensions[series][level] = (x1,x2)
+                         annotation.level = level
+                         break
+                    else:
+                        l1,l2 = dimensions[series][level]
+                        if not (x1 < l2 and l1 < x2): # ranges dont overlap
+                            ranges = (x1,x2,l1,l2)
+                            dimensions[series][level] = (min(ranges),max(ranges))
+                            annotation.level = level
+                            break
+                    level += 1
+        # group series
+        noOverlap = {}
+        offsets = {}
+        for series in dimensions:
+            y1 = min(dimensions[series].keys())
+            y2 = max(dimensions[series].keys())
+            x1= min([min(dimensions[series][level]) for level in dimensions[series]])
+            x2= max([max(dimensions[series][level]) for level in dimensions[series]])
+            offset = 0
+            while True:
+                if len(noOverlap) == 0:
+                    break
+                overlaps = False
+                for s in noOverlap:
+                    a1,a2,b1,b2 = noOverlap[s]
+                    # check overlap
+                    if (x1 < a2 and a1 < x2) and (y1+offset <= b2 and b1 <= y2+offset):
+                        overlaps = True
+                        break
+                if overlaps == False:
+                    break
+                offset += 1
+            offsets[series] = offset
+            noOverlap[series] = (x1,x2,y1+offset,y2+offset)
+        
+        # recalculate annotation level based on offset
+        for series in sorted(offsets, key=lambda s: offsets[s]):
+            for annotation in self.annotations[series]:
+                annotation.level += offsets[series]
+                self.paintAnnotation(annotation)
         self.canvas.tag_lower("annotation")
         
     def paintAnnotation(self, annotation):
-        
         pIntMin = self.convBtoY(self.viewYMin)
         pIntMax = self.convBtoY(self.viewYMax)
-        if annotation.x1 == 0:
-            return
-            
-        if annotation.x2 == 0:
-            return
-            
-        if annotation.y == 0:
-            return
-
+        #if annotation.x1 == 0:
+        #    return
+        #    
+        #if annotation.x2 == 0:
+        #    return
+        #    
+        #if annotation.y == 0:
+        #    return
+        
         px1 = self.convAtoX(annotation.x1)
         px2 = self.convAtoX(annotation.x2)
         pXText = self.convAtoX((annotation.x1+annotation.x2)/2.0)
-        py = annotation.y
+        py = annotation.level*20 + self.convBtoY(self.viewYMax)+20
         
         if annotation == self.currentAnnotation:
             tags = ("currentAnnotation", "annotation")
             color = "orange"
         else:
             tags = ("annotation", )
-            color = "green"
+            color = self.series[annotation.series]["color"]
         
-        item1 = self.canvas.create_line(px1, pIntMin, px1, pIntMax, tags=tags, fill=color)
-        item2 = self.canvas.create_line(px2, pIntMin, px2, pIntMax, tags=tags, fill=color)
-        item3 = self.canvas.create_line(px1, py, px2, py, tags=tags, fill=color)
+        #item1 = self.canvas.create_line(px1, pIntMin, px1, pIntMax, tags=tags, fill=color)
+        item1 = self.canvas.create_line(px1, pIntMin, px1, py-10, tags=tags, fill=color)
+        item2 = self.canvas.create_line(px2, pIntMin, px2, py-10, tags=tags, fill=color)
+        #item2 = self.canvas.create_line(px2, pIntMin, px2, pIntMax, tags=tags, fill=color)
+        item3 = self.canvas.create_line(px1, py, px2, py, tags=tags, fill=color,arrow="both")
         item4 = self.canvas.create_text((pXText, py, ),
                                text=annotation.text,
                                fill=color,
                                anchor="s", justify="center",
                                tags=tags)
+        
         annotation.items = {}
         annotation.items[item1] = "x1"
         annotation.items[item2] = "x2"
diff --git a/glyxtoolms/gui/DataModel.py b/glyxtoolms/gui/DataModel.py
index a47309d..c0834ca 100644
--- a/glyxtoolms/gui/DataModel.py
+++ b/glyxtoolms/gui/DataModel.py
@@ -271,6 +271,14 @@ class ContainerAnalysisFile(object):
                 feature.removeSpectrum(spectrum)
         # delete features that fall within bounds
         
+        # update identifications
+        for hit in feature.hits:
+            mass = hit.peptide.mass+hit.glycan.mass+glyxtoolms.masses.MASS["H+"]
+            precursormass = (feature.mz*feature.charge-
+                              glyxtoolms.masses.MASS["H+"]*(feature.charge-1))
+            diff = mass- precursormass
+            hit.error = diff
+        
         # remove possible identifications
         
         # update views
diff --git a/glyxtoolms/gui/FramePlot.py b/glyxtoolms/gui/FramePlot.py
index 589c64f..f10ffd8 100644
--- a/glyxtoolms/gui/FramePlot.py
+++ b/glyxtoolms/gui/FramePlot.py
@@ -68,26 +68,7 @@ class Toolbar(ttk.Frame):
         for button in self.groups[groupname]:
             button.setOff()
 
-        
-class ActionZoom(object):
-
-    def __init__(self, master, canvas, x, y):
-        self.master = master
-        self.canvas = canvas
-        self.rectangle = canvas.create_rectangle(x, y, x, y)
-        self.x = x
-        self.y = y
-
-    def onMotion(self, event):
-        # change coordinates of rectangle
-        self.canvas.coords(self.rectangle, (self.x, self.y, event.x, event.y))
-
-    def onButtonRelease(self, event):
-        x1, y1, x2, y2 = self.canvas.coords(self.rectangle)
-        self.canvas.delete(self.rectangle)
-        self.master.zoom(x1, y1, x2, y2)
-
-class FramePlot(ttk.Frame):
+class FramePlot(ttk.Frame, object):
 
     def __init__(self, master, model, height=300, width=800, xTitle="", yTitle=""):
         ttk.Frame.__init__(self, master=master)
@@ -176,10 +157,10 @@ class FramePlot(ttk.Frame):
         self.toolbar.grid(row=0, column=2, sticky="NSEW")
         
         # add toolbar buttons for zoom
-        self.toolbar.addButton("drag","defaultgroup", cursor="hand2")
-        self.toolbar.addButton("zoom_in","defaultgroup", cursor="")
-        self.toolbar.addButton("zoom_out","defaultgroup", cursor="")
-        self.toolbar.addButton("zoom_auto","defaultgroup", cursor="")
+        self.toolbar.addButton("drag","toggle", cursor="hand2")
+        self.toolbar.addButton("zoom_in","toggle", cursor="")
+        self.toolbar.addButton("zoom_out","single", cursor="")
+        self.toolbar.addButton("zoom_auto","single", cursor="")
         
         #saveButton = ttk.Button(self, text="Save Plot", command=self.savePlot)
         #saveButton.grid(row=5, column=1, sticky="NS")
@@ -322,9 +303,9 @@ class FramePlot(ttk.Frame):
         x = self.convXtoA(event.x)
         y = self.convYtoB(event.y)
         if event.num == 4:
-            sign = -1
-        elif event.num == 5:
             sign = 1
+        elif event.num == 5:
+            sign = -1
         else:
             return
         if x > 0 and y > 0:
@@ -338,7 +319,6 @@ class FramePlot(ttk.Frame):
             return
 
         self._paintCanvas(addToHistory=False)
-        #print event.__dict__
 
     def identifier(self):
         return "Frameplot"
@@ -350,25 +330,43 @@ class FramePlot(ttk.Frame):
         raise Exception("Replace function!")
         
     def toolboxButtonPressed(self):
-        if self.toolbar.active.get("defaultgroup", "") == "zoom_auto":
-            self.toolbar.deactivateGroup("defaultgroup")
+        if self.toolbar.active.get("single", "") == "zoom_auto":
+            self.toolbar.deactivateGroup("single")
             self.viewXMin = self.aMin
             self.viewXMax = self.aMax
             self.viewYMin = self.bMin
             self.viewYMax = self.bMax
             self._paintCanvas(addToHistory=False)
-
+        elif self.toolbar.active.get("single", "") == "zoom_out":
+            addX = abs(self.viewXMax-self.viewXMin)*0.1
+            self.viewXMin -= addX
+            self.viewXMax += addX
+            if self.viewXMin < self.aMin:
+                self.viewXMin = self.aMin
+            if self.viewXMax > self.aMin:
+                self.viewXMax = self.aMax
+                
+            addY = abs(self.viewYMax-self.viewYMin)*0.1
+            self.viewYMin -= addY
+            self.viewYMax += addY
+            if self.viewYMin < self.bMin:
+                self.viewYMin = self.bMin
+            if self.viewYMax > self.bMin:
+                self.viewYMax = self.bMax
+            self.toolbar.deactivateGroup("single")
+            self._paintCanvas(addToHistory=False)
+                
     def eventButton1(self, event):
         self.canvas.focus_set()
         # get current toolbar
-        if self.toolbar.active.get("defaultgroup", "") == "zoom_out":
-            event.num = 4
-            self.eventMousewheel(event)
-        elif self.toolbar.active.get("defaultgroup", "") == "zoom_in":
-            self.action = ActionZoom(self, self.canvas, event.x, event.y)
-        elif self.toolbar.active.get("defaultgroup", "") == "drag":
+        if self.toolbar.active.get("toggle", "") == "zoom_in":
+            x = event.x
+            y = event.y
+            self.action = {"name":"zoomin", "x":x, "y":y}
+            rectangle = self.canvas.create_rectangle(x, y, x, y)
+            self.action["rectangle"] = rectangle
+        elif self.toolbar.active.get("toggle", "") == "drag":
             self.action = {"name":"drag", "startx":self.convXtoA(event.x), "starty":self.convYtoB(event.y)}
-            #self.action = {"name":"drag", "startx":event.x, "starty":event.y}
 
 
     def eventMouseMotion(self, event):
@@ -383,53 +381,48 @@ class FramePlot(ttk.Frame):
     def eventMouseMotionB1(self, event):
         if self.action == None:
             return
-        try:
-            if self.action.get("name","") == "drag":
-                x = self.convXtoA(event.x)
-                y = self.convYtoB(event.y)
-
-                startx = self.action.get("startx")
-                starty = self.action.get("starty")
-                dragx = startx - x
-                dragy = starty - y
-
-                if dragx < 0 and self.viewXMin == self.aMin:
-                    dragx = 0
-                elif dragx > 0 and self.viewXMax == self.aMax:
-                    dragx = 0
-                    
-                if dragy < 0 and self.viewYMin == self.bMin:
-                    dragy = 0
-                elif dragy > 0 and self.viewYMax == self.bMax:
-                    dragy = 0
-
-                self.viewXMin += dragx
-                self.viewXMax += dragx
-                self.viewYMin += dragy
-                self.viewYMax += dragy
-                self._paintCanvas(addToHistory=False)
-                return
-        except:
-            if not hasattr(self.action, "onMotion"):
-                return
-            self.action.onMotion(event)
-
-
-#    def eventStartZoom(self, event):
-#        self.canvas.focus_set()
-#        # ToDo: Cancel previous action?
-#        self.action = ActionZoom(self, self.canvas, event.x, event.y)
-#        return
+
+        if self.action.get("name","") == "drag":
+            x = self.convXtoA(event.x)
+            y = self.convYtoB(event.y)
+
+            startx = self.action.get("startx")
+            starty = self.action.get("starty")
+            dragx = startx - x
+            dragy = starty - y
+
+            if dragx < 0 and self.viewXMin == self.aMin:
+                dragx = 0
+            elif dragx > 0 and self.viewXMax == self.aMax:
+                dragx = 0
+                
+            if dragy < 0 and self.viewYMin == self.bMin:
+                dragy = 0
+            elif dragy > 0 and self.viewYMax == self.bMax:
+                dragy = 0
+
+            self.viewXMin += dragx
+            self.viewXMax += dragx
+            self.viewYMin += dragy
+            self.viewYMax += dragy
+            self._paintCanvas(addToHistory=False)
+            return
+        elif self.action.get("name","") == "zoomin":
+            self.canvas.coords(self.action["rectangle"], 
+                               (self.action["x"], self.action["y"], 
+                               event.x, event.y))
+
+
 
 
     def eventButtonRelease(self, event):
         if self.action == None:
             return
-        if not hasattr(self.action, "onButtonRelease"):
-            return
-        self.action.onButtonRelease(event)
-        self.action = None
-        return
+        if self.action.get("name","") == "zoomin":
+            x1, y1, x2, y2 = self.canvas.coords(self.action ["rectangle"])
+            self.canvas.delete(self.action ["rectangle"])
+            self.zoom(x1, y1, x2, y2)
+            self.action = None
 
     def calcScales(self):
         if self.viewXMin == -1 or self.viewXMin < self.aMin:
@@ -457,13 +450,22 @@ class FramePlot(ttk.Frame):
         self.slopeA = self.slopeA
         
         # calculate scrollbar dimensions
-        lowX = self.viewXMin/float(self.aMax-self.aMin)
-        highX = self.viewXMax/float(self.aMax-self.aMin)
+        width = float(self.aMax-self.aMin)
+        if width > 0:
+            lowX = self.viewXMin/width
+            highX = self.viewXMax/width
+        else:
+            lowX = 0.0
+            highX = 1.0
         self.hbar.set(lowX, highX)
         
         height = float(self.bMax-self.bMin)
-        highY = 1.0 - self.viewYMin / height
-        lowY = 1.0 - self.viewYMax / height
+        if height > 0:
+            highY = 1.0 - self.viewYMin / height
+            lowY = 1.0 - self.viewYMax / height
+        else:
+            lowY = 0.0
+            highY = 1.0
         self.vbar.set(lowY, highY)
 
     def convAtoX(self, A):
diff --git a/glyxtoolms/gui/SpectrumView2.py b/glyxtoolms/gui/SpectrumView2.py
index b8a28c3..99101da 100644
--- a/glyxtoolms/gui/SpectrumView2.py
+++ b/glyxtoolms/gui/SpectrumView2.py
@@ -16,11 +16,6 @@ class Annotation(object):
         self.items = {}
         self.selected = ""
 """
-class Peak:
-    
-    def __init__(self,x,y):
-        self.x = x
-        self.y = y
 
 class SpectrumView(AnnotatedPlot.AnnotatedPlot):
 
@@ -33,7 +28,9 @@ class SpectrumView(AnnotatedPlot.AnnotatedPlot):
         self.spec = None # Link to raw spectrum
         self.spectrum = None # Link to current spectrum score
 
-        self.peaksByItem = {}
+        #self.peaksByItem = {}
+        self.clearAnnotatableList()
+        
         self.annotationItems = {}
         self.annotations = []
         self.currentAnnotation = None
@@ -77,7 +74,8 @@ class SpectrumView(AnnotatedPlot.AnnotatedPlot):
              self.annotations = self.model.currentAnalysis.spectraIds[spec.getNativeID()].annotations
         self.spec = spec
         self.referenceMass = 0
-        self.peaksByItem = {}
+        #self.peaksByItem = {}
+        self.clearAnnotatableList()
         self.annotationItems = {}
         self.currentAnnotation = None
         self.initCanvas()
@@ -111,7 +109,7 @@ class SpectrumView(AnnotatedPlot.AnnotatedPlot):
                 continue
             if intens < self.viewYMin:
                 continue
-            peaks.append(Peak(mz,intens))
+            peaks.append(AnnotatedPlot.Annotatable(mz,intens))
 
         # sort peaks after highest intensity
         peaks.sort(reverse=True, key=lambda p: p.y)
@@ -136,7 +134,8 @@ class SpectrumView(AnnotatedPlot.AnnotatedPlot):
         scoredPeaks = []
         annotationText = []
         annotationMass = []
-        self.peaksByItem = {}
+        self.clearAnnotatableList()
+
         for p in peaks:
             # check if peak is a scored peak
             pMZ = self.convAtoX(p.x)
@@ -148,7 +147,7 @@ class SpectrumView(AnnotatedPlot.AnnotatedPlot):
                 annotationText.append((pMZ, pInt, fragment+"\n"+masstext))
             else:
                 item = self.canvas.create_line(pMZ, pInt0, pMZ, pInt, tags=("peak", ), fill="black")
-                self.peaksByItem[item] = p
+                self.addAnnotatableItem(item, p)
                 annotationMass.append((pMZ, pInt, masstext))
 
             self.allowZoom = True
@@ -159,7 +158,7 @@ class SpectrumView(AnnotatedPlot.AnnotatedPlot):
             pMZ = self.convAtoX(p.x)
             pInt = self.convBtoY(p.y)
             item = self.canvas.create_line(pMZ, pInt0, pMZ, pInt, tags=("peak", ), fill="red")
-            self.peaksByItem[item] = p
+            self.addAnnotatableItem(item, p)
 
         items = self.plotText(annotationText, set(), 0)
         items = self.plotText(annotationMass, items, 5)
diff --git a/glyxtoolms/io.py b/glyxtoolms/io.py
index 4b12da1..a877c24 100644
--- a/glyxtoolms/io.py
+++ b/glyxtoolms/io.py
@@ -25,6 +25,9 @@ class Annotation(object):
         self.x2 = 0
         self.y = 0
         self.text = ""
+        self.series = ""
+        self.nr = 0
+        self.level = 0
 
 class GlyxXMLSpectrum(object):
     """ Define the GlyxXMLSpectrum as used in the glyML format """
